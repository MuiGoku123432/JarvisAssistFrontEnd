var C=Object.defineProperty;var D=(e,t,s)=>t in e?C(e,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):e[t]=s;var l=(e,t,s)=>D(e,typeof t!="symbol"?t+"":t,s);const L=(e,t=s=>s!==void 0?": "+s:"")=>class extends Error{constructor(i){super(e(i)+t(i));l(this,"origMessage");this.origMessage=i!==void 0?String(i):""}},$=L(()=>"illegal argument(s)"),j=e=>{throw new $(e)},v=L(()=>"illegal state"),G=e=>{throw new v(e)},H=Math.pow(2,32);class T{constructor(t,s=0,i=t.length<<3){l(this,"buffer");l(this,"start");l(this,"limit");l(this,"pos");l(this,"bitPos");l(this,"bit");this.buffer=t,this.start=s,this.limit=i,this.seek(s)}*[Symbol.iterator](){let t=this.start,s=t>>>3,i=7-(t&7);for(;t<this.limit;)yield this.buffer[s]>>>i&1,--i<0&&(s++,i=7),t++}get length(){return this.limit}get position(){return this.bitPos}seek(t){return(t<this.start||t>=this.limit)&&j(`seek pos out of bounds: ${t}`),this.pos=t>>>3,this.bit=8-(t&7),this.bitPos=t,this}read(t=1){if(t>32)return this.read(t-32)*H+this.read(32);if(t>8){let s=0,i=t&-8,n=t-i;for(n>0&&(s=this._read(n));i>0;)s=(s<<8|this._read(8))>>>0,i-=8;return s}else return this._read(t)}readFields(t){return t.map(s=>this.read(s))}readWords(t,s=8){let i=[];for(;t-- >0;)i.push(this.read(s));return i}readStruct(t){return t.reduce((s,[i,n])=>(s[i]=this.read(n),s),{})}readBit(){this.checkLimit(1),this.bit--,this.bitPos++;let t=this.buffer[this.pos]>>>this.bit&1;return this.bit===0&&(this.pos++,this.bit=8),t}_read(t){this.checkLimit(t);let s=this.bit-t,i;return s>=0?(this.bit=s,i=this.buffer[this.pos]>>>s&(1<<t)-1,s===0&&(this.pos++,this.bit=8)):(i=(this.buffer[this.pos++]&(1<<this.bit)-1)<<-s,this.bit=8+s,i=i|this.buffer[this.pos]>>>this.bit),this.bitPos+=t,i}checkLimit(t){this.bitPos+t>this.limit&&G("can't read past EOF")}}const I=16,m=20,_=4,U=1903124838;function W(e,t,s){return e<t?t:e>s?s:e}function Z(e,t){const s=new Int16Array(4),i=new Int16Array(4);return{history:s,weights:i}}function J(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]+e[3]*t[3]>>13}function K(e,t,s,i){let n=i>>4;e[0]+=t[0]<0?-n:n,e[1]+=t[1]<0?-n:n,e[2]+=t[2]<0?-n:n,e[3]+=t[3]<0?-n:n,t[0]=t[1],t[1]=t[2],t[2]=t[3],t[3]=s}const k=e=>Math.sign(e)*Math.round(Math.abs(e)),x=Array(16).fill().map((e,t)=>k(Math.pow(t+1,2.75))),V=[.75,-.75,2.5,-2.5,4.5,-4.5,7,-7],X=x.map(e=>V.map(t=>k(t*e)));function Y(e){if(e.read(32)!==U)throw new Error("Not a QOA file; expected magic number 'qoaf'");const s={samples:e.read(32),channels:e.read(8),sampleRate:e.read(24)};return e.seek(64),s}function y(e,t,s,i,n){const r=e.read(8),d=e.read(24),c=e.read(16),b=e.read(16),O=Math.floor(b-8-_*4*r),S=Math.floor(O/8)*m;if(r!=t.channels||d!=t.sampleRate||c*r>S)throw new Error("invalid frame header data");for(let o=0;o<r;o++){const h=s[o];for(let a=0;a<_;a++){let u=e.read(16);h.history[a]=u}for(let a=0;a<_;a++){let u=e.read(16);h.weights[a]=u}}for(let o=0;o<c;o+=m)for(let h=0;h<r;h++){const a=e.read(4),u=X[a],g=o,P=Math.min(o+m,c)-g,M=s[h],Q=i[h];let F=n+g;const A=M.weights,E=M.history;let p=60;for(let q=0;q<P;q++){const N=J(A,E),R=e.read(3),w=u[R],f=W(N+w,-32768,32767),B=f<0?f/32768:f/32767;Q[F++]=B,K(A,E,f,w),p-=3}p>0&&e.read(p)}return c}function st(e){if(e.byteLength<I)throw new Error(`QOA file size must be >= ${I}`);const t=new T(e),s=Y(t),i=[],n=[];for(let c=0;c<s.channels;c++){const b=new Float32Array(s.samples);i.push(b),n.push(Z())}let r=0,d=0;do d=y(t,s,n,i,r),r+=d;while(d&&r<s.samples);return{...s,channelData:i}}x.map(e=>Math.floor((65536+e-1)/e));export{st as decode};
